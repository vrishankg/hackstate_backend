# -*- coding: utf-8 -*-
"""hackathon.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zmLNyFYr80-KLDkO-DvLUhXalB1osi9E
"""

import pandas as pd
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import OneHotEncoder
from scipy.spatial import distance
import numpy as np
from datetime import time
from datetime import datetime

restaurants = pd.DataFrame({
    'name': ['The Gourmet Spot', 'Family Feast', 'Vegan Delight', 'Quick Bites', 'Fine Dine In'],
    'preferred_cuisines': ['Italian', 'American', 'Vegan', 'Fast Food', 'French'],
    'budget': ['$$', '$', '$$', '$', '$$$$'],
    'city': ['Raleigh', 'Raleigh', 'Raleigh', 'Raleigh', 'Raleigh'],
    'state': ['NC', 'NC', 'NC', 'NC', 'NC'],
    'coordinates': [(35.7796, -78.6382), (35.7796, -78.6382), (35.7796, -78.6382), (35.7796, -78.6382), (35.7796, -78.6382)],
    'preferred_ambiance': ['Romantic', 'Casual', 'Quiet', 'Casual', 'Elegant'],
    'dietary_restrictions': ['None', 'None', 'Vegan', 'None', 'None'],
    'menu_url': ['http://example.com/restaurant1/menu', 'http://example.com/restaurant2/menu', 'http://example.com/restaurant2/menu', 'http://example.com/restaurant2/menu', 'http://example.com/restaurant2/menu'],
    'start_time':[time(10, 0), time(9, 0), time(11, 0), time(8, 0), time(18, 0)],
    'end_time': [time(22, 0), time(21, 0), time(23, 0), time(20, 0), time(23, 0)]
})





current_time = datetime.now().time()

user_preferences = {
    'id': 'user_name',
    'name': 'John',
    'preferred_cuisines': ['Italian'],
    'budget': '$$',
    'preferred_ambiance': 'Quiet',
    'location_preference': (35.7796, -78.6382),
    'dietary_restrictions': ['Vegan'],
    'city': 'Raleigh',
    'state': 'NC',
    'preferred_language': 'es',
    'current_time': current_time,
    'feature_importance': {
        'preferred_cuisines': 5,
        'budget': 4,
        'preferred_ambiance': 3,
        'dietary_restrictions': 5
    },
}

open_restaurants = restaurants[(restaurants['start_time'] <= user_preferences['current_time']) & (restaurants['end_time'] > user_preferences['current_time'])]

if open_restaurants.empty:
    print("No restaurants are open at this time.")
    #
else:
    enc = OneHotEncoder()
    restaurant_features = enc.fit_transform(restaurants[['preferred_cuisines', 'budget', 'city', 'state', 'preferred_ambiance', 'dietary_restrictions']]).toarray()

    # Convert user_preferences to DataFrame and transform
    user_preferences_adjusted = {
        'preferred_cuisines': user_preferences['preferred_cuisines'][0],
        'budget': user_preferences['budget'],
        'city': user_preferences['city'],
        'state': user_preferences['state'],
        'preferred_ambiance': user_preferences['preferred_ambiance'],
        'dietary_restrictions': user_preferences['dietary_restrictions'][0]
    }
    user_df_adjusted = pd.DataFrame([user_preferences_adjusted])
    user_features = enc.transform(user_df_adjusted).toarray()

    # Calculate cosine similarity for categorical features
    similarity_scores = cosine_similarity(user_features, restaurant_features[open_restaurants.index])

    # Apply feature importance weights
    for feature, enc_feature in zip(['preferred_cuisines', 'budget', 'city', 'state', 'preferred_ambiance', 'dietary_restrictions'], enc.get_feature_names_out()):
        weight = user_preferences['feature_importance'][feature] / 5  # Normalize weights to be between 0 and 1
        feature_index = np.where(enc_feature == feature)[0]  # Get the column index of the feature
        if feature_index.size > 0:
            similarity_scores[:, feature_index] *= weight

    # Re-normalize the similarity scores
    similarity_scores = similarity_scores / np.max(similarity_scores)

    # Calculate Euclidean distance for coordinates and filter based on a radius
    user_location = np.array(user_preferences['location_preference'])
    restaurant_locations = np.stack(open_restaurants['coordinates'])
    location_distances = distance.cdist([user_location], restaurant_locations, 'euclidean')[0]

    # Normalize distances
    max_distance = np.max(location_distances)
    normalized_distances = location_distances / max_distance

    # Filter based on a radius
    max_radius = 10  # Example radius in km or miles, depending on your coordinate unit
    filtered_restaurants_index = location_distances <= max_radius
    filtered_restaurants = open_restaurants[filtered_restaurants_index]

    # Add similarity score to DataFrame
    filtered_restaurants['similarity_score'] = similarity_scores[0][filtered_restaurants_index]

    # Sort restaurants based on similarity score
    recommended_restaurants = filtered_restaurants.sort_values(by='similarity_score', ascending=False)

    # Display top N recommendations
    N = 3
    print(recommended_restaurants.head(N))